
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.dynatrace.metric.calculator;

import com.dynatrace.diagnostics.pdk.*;
import java.util.logging.Logger;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collection;


import javax.net.ssl.*;

import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import org.apache.http.client.ClientProtocolException;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;


public class Engine implements Monitor {

	private static final Logger log = Logger.getLogger(Engine.class.getName());


	// measure constants
	private static final String METRIC_GROUP = "Results";
	private static final String CALC_RESULTS = "Calc Results";

	private Collection<MonitorMeasure>  measures  = null;
	
	private double results;

	private URLConnection connection;
	private URL matrixURL;
	
	private String urlprotocol;
	private int urlport;
	private String dynaTraceURL;
	private String username;
	private String password;
	
	private String operation;
	private String aggergation;

	@Override
	public Status setup(MonitorEnvironment env) throws Exception {
		
		log.finer("*****BEGIN PLUGIN LOGGING*****");
		log.finer("Entering setup method");
		log.finer("Entering variables from plugin.xml");
		
		this.urlprotocol = env.getConfigString("protocol");
		this.urlport = env.getConfigLong("httpPort").intValue();
		
		this.dynaTraceURL = env.getConfigString("matrixURL");
		this.dynaTraceURL = dynaTraceURL.replaceAll(" ", "%20");
		
		if (!this.dynaTraceURL.startsWith("/"))
			this.dynaTraceURL = "/" + this.dynaTraceURL;
		
		this.username = env.getConfigString("username");
		this.password = env.getConfigPassword("password");
				
		this.operation = env.getConfigString("operation");
		this.aggergation = env.getConfigString("aggergation");
		this.aggergation = this.aggergation.toLowerCase();
		
		log.finer("URL Protocol: " + this.urlprotocol);
		log.finer("URL Port: " + this.urlport);
		log.finer("dT URL: " + this.dynaTraceURL);
		log.finer("Username: " + this.username);
		log.finer("Operation: " + this.operation);
		log.finer("Aggergation: " + this.aggergation);
		
		log.finer("Exiting setup method");
			
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception {
		
		log.finer("Entering execute method");
		
		log.finer("Entering URL Setup");
		this.matrixURL = new URL(urlprotocol, env.getHost().getAddress(), urlport, dynaTraceURL);		
		
		log.info("Executing URL: " + this.matrixURL.toString());
		log.finer("Executing URL: " + this.matrixURL.toString());
		
		try {
			
			log.finer("Entering username/password setup");
			String userpass = this.username + ":" + this.password;
			String basicAuth = "Basic " + javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());
		
			disableCertificateValidation();
				
			//URL to grab XML file
			log.finer("Entering XML file grab");
			this.connection = this.matrixURL.openConnection();
			this.connection.setRequestProperty("Authorization", basicAuth);
			this.connection.setConnectTimeout(50000);

			//Build out XML Document
			InputStream responseIS = this.connection.getInputStream();	
			DocumentBuilderFactory xmlFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder docBuilder = xmlFactory.newDocumentBuilder();
			Document xmlDoc = docBuilder.parse(responseIS);
			XPathFactory xpathFact = XPathFactory.newInstance();
			XPath xpath = xpathFact.newXPath();
			
			//Create XPath Query to build out list of nodes to be evaluated on	
			String xpathQuery = "/dashboardreport/data/dynamicmeasurematrixdashlet/measures/measure";
			NodeList nl = (NodeList) xpath.evaluate(xpathQuery,xmlDoc,XPathConstants.NODESET);
						
			//Java 6 doesn't support a string in the switch statement
			log.finer("Entering splitting switch statement");
			int splitSwitch = 0;
			if (operation.equals("Add"))
				splitSwitch = 1;
			if (operation.equals("Sub"))
				splitSwitch = 2;
			if (operation.equals("Mul"))
				splitSwitch = 3;
			log.finer("splitSwitch: " + splitSwitch);
			
			//Switch to which operation is selected to use
			switch(splitSwitch){
				case 1: //Add
					//Loop through nodes to get all values then perform addition on values cumulatively
					for (int i = 0; i < nl.getLength();i++){ 
							this.results = this.results + xmlHelper(nl,i);
						}
					break;
				case 2: //Sub
					//Loop through nodes to get all values then perform subtraction on values cumulatively
					for (int i = 0; i < nl.getLength();i++){
						this.results = xmlHelper(nl,i) - this.results;
					}
					break;
				case 3: //Multi
					//Loop through nodes to get all values then perform multiplication on values cumulatively
					for (int i = 0; i < nl.getLength();i++){
						this.results = this.results + xmlHelper(nl,i);
					}
					break;
				default:
					//There should always be a value this is in case switch helper up top does not match plugin
					//properties exactly
					throw new Exception();
			}
			
			//Add value to be reported to metric group for plugin
			if ((measures = env.getMonitorMeasures(METRIC_GROUP, CALC_RESULTS)) != null) {
				log.finer(measures.toString());
				log.finer("Results to publish" +this.results);
				for (MonitorMeasure measure : measures)
					measure.setValue(this.results);
			}

		} catch (ClientProtocolException e) {
			log.info("ClientProtocolException: " + e);
			return new Status(Status.StatusCode.ErrorInternal);

		} catch (IOException e) {
			log.info("IOException: " + e);
			return new Status(Status.StatusCode.ErrorInternal);

		} catch (Exception e){
			log.info("Exception: " + e);
			return new Status(Status.StatusCode.ErrorInternal);
		}
		
		log.finer("Exiting execute method");
		log.finer("*****END PLUGIN LOGGING*****");
		return new Status(Status.StatusCode.Success);
	}

	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// No tear down required due to rest queries closing above
	}
	
	 
	/*
	 * Helper class to extract values out of the node list to then run mathematics on
	 * @Param NodeList, int
	 * @Return double
	 */
	private double xmlHelper(NodeList nl, int i){
		log.finer("Entering xmlHelper method");
		if(nl.item(i).getAttributes().getNamedItem("drawingorder") == null){
			String tempString = nl.item(i).getAttributes().getNamedItem(this.aggergation).toString();
			log.fine("String Line" + tempString);
			tempString = tempString.replace(this.aggergation + "=", "");
			tempString = tempString.replace("\"", "");
			log.finer("Number Value extracted: " + tempString);
			log.finer("Exiting xmlHelper method");
			return Double.parseDouble(tempString);
		}else{
			log.finer("Exiting xmlHelper method");
			return 0;
		}	
	}
	
	public static void disableCertificateValidation() {
		
		log.finer("Entering disableCertificateValidation method");  
		
		// Create a trust manager that does not validate certificate chains
		  TrustManager[] trustAllCerts = new TrustManager[] { 
		    new X509TrustManager() {
		      public X509Certificate[] getAcceptedIssuers() { 
		        return new X509Certificate[0]; 
		      }
		      public void checkClientTrusted(X509Certificate[] certs, String authType) {}
		      public void checkServerTrusted(X509Certificate[] certs, String authType) {}
		  }};

		  // Ignore differences between given hostname and certificate hostname
		  HostnameVerifier hv = new HostnameVerifier() {
		    public boolean verify(String hostname, SSLSession session) { return true; }
		  };

		  // Install the all-trusting trust manager
		  try {
		    SSLContext sc = SSLContext.getInstance("SSL");
		    sc.init(null, trustAllCerts, new SecureRandom());
		    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
		    HttpsURLConnection.setDefaultHostnameVerifier(hv);
		  } catch (Exception e) {}
		  
		  log.finer("Leaving disableCertificateValidation method");
	}
}
